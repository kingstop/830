// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.proto

#ifndef PROTOBUF_login_2eproto__INCLUDED
#define PROTOBUF_login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)

namespace clientmsg {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_login_2eproto();
void protobuf_AssignDesc_login_2eproto();
void protobuf_ShutdownFile_login_2eproto();

class LoginRequest;
class LoginResponse;
class LoginGame;
class ClientInit;
class CreateChar;
class ClientExit;
class SendChat;
class SendGreet;
class WordWindow;
class ChangeCloth;
class Assess;

enum enumLoginResult {
  enumLoginResult_Success = 0,
  enumLoginResult_Fail = 1,
  enumLoginResult_NameFail = 2,
  enumLoginResult_PwdFail = 3,
  enumLoginResult_HaveLogin = 4
};
bool enumLoginResult_IsValid(int value);
const enumLoginResult enumLoginResult_MIN = enumLoginResult_Success;
const enumLoginResult enumLoginResult_MAX = enumLoginResult_HaveLogin;
const int enumLoginResult_ARRAYSIZE = enumLoginResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* enumLoginResult_descriptor();
inline const ::std::string& enumLoginResult_Name(enumLoginResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    enumLoginResult_descriptor(), value);
}
inline bool enumLoginResult_Parse(
    const ::std::string& name, enumLoginResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<enumLoginResult>(
    enumLoginResult_descriptor(), name, value);
}
enum enumChatType {
  Chat_User = 1,
  Chat_World = 2,
  Chat_Sys = 3
};
bool enumChatType_IsValid(int value);
const enumChatType enumChatType_MIN = Chat_User;
const enumChatType enumChatType_MAX = Chat_Sys;
const int enumChatType_ARRAYSIZE = enumChatType_MAX + 1;

const ::google::protobuf::EnumDescriptor* enumChatType_descriptor();
inline const ::std::string& enumChatType_Name(enumChatType value) {
  return ::google::protobuf::internal::NameOfEnum(
    enumChatType_descriptor(), value);
}
inline bool enumChatType_Parse(
    const ::std::string& name, enumChatType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<enumChatType>(
    enumChatType_descriptor(), name, value);
}
// ===================================================================

class LoginRequest : public ::google::protobuf::Message {
 public:
  LoginRequest();
  virtual ~LoginRequest();

  LoginRequest(const LoginRequest& from);

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRequest& default_instance();

  void Swap(LoginRequest* other);

  // implements Message ----------------------------------------------

  LoginRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRequest& from);
  void MergeFrom(const LoginRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string pwd = 2;
  inline bool has_pwd() const;
  inline void clear_pwd();
  static const int kPwdFieldNumber = 2;
  inline const ::std::string& pwd() const;
  inline void set_pwd(const ::std::string& value);
  inline void set_pwd(const char* value);
  inline void set_pwd(const char* value, size_t size);
  inline ::std::string* mutable_pwd();
  inline ::std::string* release_pwd();
  inline void set_allocated_pwd(::std::string* pwd);

  // @@protoc_insertion_point(class_scope:clientmsg.LoginRequest)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_pwd();
  inline void clear_has_pwd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* pwd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginRequest* default_instance_;
};
// -------------------------------------------------------------------

class LoginResponse : public ::google::protobuf::Message {
 public:
  LoginResponse();
  virtual ~LoginResponse();

  LoginResponse(const LoginResponse& from);

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginResponse& default_instance();

  void Swap(LoginResponse* other);

  // implements Message ----------------------------------------------

  LoginResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginResponse& from);
  void MergeFrom(const LoginResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string gate_ip = 1;
  inline bool has_gate_ip() const;
  inline void clear_gate_ip();
  static const int kGateIpFieldNumber = 1;
  inline const ::std::string& gate_ip() const;
  inline void set_gate_ip(const ::std::string& value);
  inline void set_gate_ip(const char* value);
  inline void set_gate_ip(const char* value, size_t size);
  inline ::std::string* mutable_gate_ip();
  inline ::std::string* release_gate_ip();
  inline void set_allocated_gate_ip(::std::string* gate_ip);

  // optional uint32 gate_port = 2;
  inline bool has_gate_port() const;
  inline void clear_gate_port();
  static const int kGatePortFieldNumber = 2;
  inline ::google::protobuf::uint32 gate_port() const;
  inline void set_gate_port(::google::protobuf::uint32 value);

  // optional uint32 user_account = 3;
  inline bool has_user_account() const;
  inline void clear_user_account();
  static const int kUserAccountFieldNumber = 3;
  inline ::google::protobuf::uint32 user_account() const;
  inline void set_user_account(::google::protobuf::uint32 value);

  // optional .clientmsg.enumLoginResult result = 4;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 4;
  inline ::clientmsg::enumLoginResult result() const;
  inline void set_result(::clientmsg::enumLoginResult value);

  // optional uint32 chartype = 5;
  inline bool has_chartype() const;
  inline void clear_chartype();
  static const int kChartypeFieldNumber = 5;
  inline ::google::protobuf::uint32 chartype() const;
  inline void set_chartype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:clientmsg.LoginResponse)
 private:
  inline void set_has_gate_ip();
  inline void clear_has_gate_ip();
  inline void set_has_gate_port();
  inline void clear_has_gate_port();
  inline void set_has_user_account();
  inline void clear_has_user_account();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_chartype();
  inline void clear_has_chartype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gate_ip_;
  ::google::protobuf::uint32 gate_port_;
  ::google::protobuf::uint32 user_account_;
  int result_;
  ::google::protobuf::uint32 chartype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginResponse* default_instance_;
};
// -------------------------------------------------------------------

class LoginGame : public ::google::protobuf::Message {
 public:
  LoginGame();
  virtual ~LoginGame();

  LoginGame(const LoginGame& from);

  inline LoginGame& operator=(const LoginGame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginGame& default_instance();

  void Swap(LoginGame* other);

  // implements Message ----------------------------------------------

  LoginGame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginGame& from);
  void MergeFrom(const LoginGame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 user_account = 1;
  inline bool has_user_account() const;
  inline void clear_user_account();
  static const int kUserAccountFieldNumber = 1;
  inline ::google::protobuf::uint32 user_account() const;
  inline void set_user_account(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:clientmsg.LoginGame)
 private:
  inline void set_has_user_account();
  inline void clear_has_user_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 user_account_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginGame* default_instance_;
};
// -------------------------------------------------------------------

class ClientInit : public ::google::protobuf::Message {
 public:
  ClientInit();
  virtual ~ClientInit();

  ClientInit(const ClientInit& from);

  inline ClientInit& operator=(const ClientInit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientInit& default_instance();

  void Swap(ClientInit* other);

  // implements Message ----------------------------------------------

  ClientInit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientInit& from);
  void MergeFrom(const ClientInit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CharInfo charinfo = 1;
  inline bool has_charinfo() const;
  inline void clear_charinfo();
  static const int kCharinfoFieldNumber = 1;
  inline const ::CharInfo& charinfo() const;
  inline ::CharInfo* mutable_charinfo();
  inline ::CharInfo* release_charinfo();
  inline void set_allocated_charinfo(::CharInfo* charinfo);

  // optional .enumGetCharResult result = 2;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 2;
  inline ::enumGetCharResult result() const;
  inline void set_result(::enumGetCharResult value);

  // @@protoc_insertion_point(class_scope:clientmsg.ClientInit)
 private:
  inline void set_has_charinfo();
  inline void clear_has_charinfo();
  inline void set_has_result();
  inline void clear_has_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CharInfo* charinfo_;
  int result_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ClientInit* default_instance_;
};
// -------------------------------------------------------------------

class CreateChar : public ::google::protobuf::Message {
 public:
  CreateChar();
  virtual ~CreateChar();

  CreateChar(const CreateChar& from);

  inline CreateChar& operator=(const CreateChar& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreateChar& default_instance();

  void Swap(CreateChar* other);

  // implements Message ----------------------------------------------

  CreateChar* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CreateChar& from);
  void MergeFrom(const CreateChar& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .CharInfo charinfo = 1;
  inline bool has_charinfo() const;
  inline void clear_charinfo();
  static const int kCharinfoFieldNumber = 1;
  inline const ::CharInfo& charinfo() const;
  inline ::CharInfo* mutable_charinfo();
  inline ::CharInfo* release_charinfo();
  inline void set_allocated_charinfo(::CharInfo* charinfo);

  // optional uint32 mapid = 2;
  inline bool has_mapid() const;
  inline void clear_mapid();
  static const int kMapidFieldNumber = 2;
  inline ::google::protobuf::uint32 mapid() const;
  inline void set_mapid(::google::protobuf::uint32 value);

  // optional uint32 cityid = 3;
  inline bool has_cityid() const;
  inline void clear_cityid();
  static const int kCityidFieldNumber = 3;
  inline ::google::protobuf::uint32 cityid() const;
  inline void set_cityid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:clientmsg.CreateChar)
 private:
  inline void set_has_charinfo();
  inline void clear_has_charinfo();
  inline void set_has_mapid();
  inline void clear_has_mapid();
  inline void set_has_cityid();
  inline void clear_has_cityid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::CharInfo* charinfo_;
  ::google::protobuf::uint32 mapid_;
  ::google::protobuf::uint32 cityid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static CreateChar* default_instance_;
};
// -------------------------------------------------------------------

class ClientExit : public ::google::protobuf::Message {
 public:
  ClientExit();
  virtual ~ClientExit();

  ClientExit(const ClientExit& from);

  inline ClientExit& operator=(const ClientExit& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientExit& default_instance();

  void Swap(ClientExit* other);

  // implements Message ----------------------------------------------

  ClientExit* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientExit& from);
  void MergeFrom(const ClientExit& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // optional uint64 user_account = 2;
  inline bool has_user_account() const;
  inline void clear_user_account();
  static const int kUserAccountFieldNumber = 2;
  inline ::google::protobuf::uint64 user_account() const;
  inline void set_user_account(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:clientmsg.ClientExit)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_user_account();
  inline void clear_has_user_account();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 user_account_;
  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ClientExit* default_instance_;
};
// -------------------------------------------------------------------

class SendChat : public ::google::protobuf::Message {
 public:
  SendChat();
  virtual ~SendChat();

  SendChat(const SendChat& from);

  inline SendChat& operator=(const SendChat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendChat& default_instance();

  void Swap(SendChat* other);

  // implements Message ----------------------------------------------

  SendChat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendChat& from);
  void MergeFrom(const SendChat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .clientmsg.enumChatType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::clientmsg::enumChatType type() const;
  inline void set_type(::clientmsg::enumChatType value);

  // optional uint32 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // optional string msg = 3;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 3;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:clientmsg.SendChat)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 charid_;
  ::std::string* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SendChat* default_instance_;
};
// -------------------------------------------------------------------

class SendGreet : public ::google::protobuf::Message {
 public:
  SendGreet();
  virtual ~SendGreet();

  SendGreet(const SendGreet& from);

  inline SendGreet& operator=(const SendGreet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendGreet& default_instance();

  void Swap(SendGreet* other);

  // implements Message ----------------------------------------------

  SendGreet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SendGreet& from);
  void MergeFrom(const SendGreet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 charid = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 1;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // optional uint32 greetid = 2;
  inline bool has_greetid() const;
  inline void clear_greetid();
  static const int kGreetidFieldNumber = 2;
  inline ::google::protobuf::uint32 greetid() const;
  inline void set_greetid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:clientmsg.SendGreet)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_greetid();
  inline void clear_has_greetid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 charid_;
  ::google::protobuf::uint32 greetid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static SendGreet* default_instance_;
};
// -------------------------------------------------------------------

class WordWindow : public ::google::protobuf::Message {
 public:
  WordWindow();
  virtual ~WordWindow();

  WordWindow(const WordWindow& from);

  inline WordWindow& operator=(const WordWindow& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WordWindow& default_instance();

  void Swap(WordWindow* other);

  // implements Message ----------------------------------------------

  WordWindow* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WordWindow& from);
  void MergeFrom(const WordWindow& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .enumWordmsgType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::enumWordmsgType type() const;
  inline void set_type(::enumWordmsgType value);

  // optional string content = 2;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 2;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:clientmsg.WordWindow)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_content();
  inline void clear_has_content();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* content_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static WordWindow* default_instance_;
};
// -------------------------------------------------------------------

class ChangeCloth : public ::google::protobuf::Message {
 public:
  ChangeCloth();
  virtual ~ChangeCloth();

  ChangeCloth(const ChangeCloth& from);

  inline ChangeCloth& operator=(const ChangeCloth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ChangeCloth& default_instance();

  void Swap(ChangeCloth* other);

  // implements Message ----------------------------------------------

  ChangeCloth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ChangeCloth& from);
  void MergeFrom(const ChangeCloth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 clothid = 1;
  inline bool has_clothid() const;
  inline void clear_clothid();
  static const int kClothidFieldNumber = 1;
  inline ::google::protobuf::uint32 clothid() const;
  inline void set_clothid(::google::protobuf::uint32 value);

  // optional uint32 charid = 2;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharidFieldNumber = 2;
  inline ::google::protobuf::uint32 charid() const;
  inline void set_charid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:clientmsg.ChangeCloth)
 private:
  inline void set_has_clothid();
  inline void clear_has_clothid();
  inline void set_has_charid();
  inline void clear_has_charid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clothid_;
  ::google::protobuf::uint32 charid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ChangeCloth* default_instance_;
};
// -------------------------------------------------------------------

class Assess : public ::google::protobuf::Message {
 public:
  Assess();
  virtual ~Assess();

  Assess(const Assess& from);

  inline Assess& operator=(const Assess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Assess& default_instance();

  void Swap(Assess* other);

  // implements Message ----------------------------------------------

  Assess* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Assess& from);
  void MergeFrom(const Assess& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .enumAssessType assesstype = 1;
  inline bool has_assesstype() const;
  inline void clear_assesstype();
  static const int kAssesstypeFieldNumber = 1;
  inline ::enumAssessType assesstype() const;
  inline void set_assesstype(::enumAssessType value);

  // optional .enumCharType chartype = 2;
  inline bool has_chartype() const;
  inline void clear_chartype();
  static const int kChartypeFieldNumber = 2;
  inline ::enumCharType chartype() const;
  inline void set_chartype(::enumCharType value);

  // optional uint32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 rank = 4;
  inline bool has_rank() const;
  inline void clear_rank();
  static const int kRankFieldNumber = 4;
  inline ::google::protobuf::uint32 rank() const;
  inline void set_rank(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:clientmsg.Assess)
 private:
  inline void set_has_assesstype();
  inline void clear_has_assesstype();
  inline void set_has_chartype();
  inline void clear_has_chartype();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_rank();
  inline void clear_has_rank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int assesstype_;
  int chartype_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 rank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static Assess* default_instance_;
};
// ===================================================================


// ===================================================================

// LoginRequest

// optional string name = 1;
inline bool LoginRequest::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRequest::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoginRequest::name() const {
  return *name_;
}
inline void LoginRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoginRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoginRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pwd = 2;
inline bool LoginRequest::has_pwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRequest::set_has_pwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRequest::clear_has_pwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRequest::clear_pwd() {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    pwd_->clear();
  }
  clear_has_pwd();
}
inline const ::std::string& LoginRequest::pwd() const {
  return *pwd_;
}
inline void LoginRequest::set_pwd(const ::std::string& value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void LoginRequest::set_pwd(const char* value) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(value);
}
inline void LoginRequest::set_pwd(const char* value, size_t size) {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  pwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginRequest::mutable_pwd() {
  set_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    pwd_ = new ::std::string;
  }
  return pwd_;
}
inline ::std::string* LoginRequest::release_pwd() {
  clear_has_pwd();
  if (pwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pwd_;
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginRequest::set_allocated_pwd(::std::string* pwd) {
  if (pwd_ != &::google::protobuf::internal::kEmptyString) {
    delete pwd_;
  }
  if (pwd) {
    set_has_pwd();
    pwd_ = pwd;
  } else {
    clear_has_pwd();
    pwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// LoginResponse

// optional string gate_ip = 1;
inline bool LoginResponse::has_gate_ip() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginResponse::set_has_gate_ip() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginResponse::clear_has_gate_ip() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginResponse::clear_gate_ip() {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    gate_ip_->clear();
  }
  clear_has_gate_ip();
}
inline const ::std::string& LoginResponse::gate_ip() const {
  return *gate_ip_;
}
inline void LoginResponse::set_gate_ip(const ::std::string& value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void LoginResponse::set_gate_ip(const char* value) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(value);
}
inline void LoginResponse::set_gate_ip(const char* value, size_t size) {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  gate_ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginResponse::mutable_gate_ip() {
  set_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    gate_ip_ = new ::std::string;
  }
  return gate_ip_;
}
inline ::std::string* LoginResponse::release_gate_ip() {
  clear_has_gate_ip();
  if (gate_ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gate_ip_;
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginResponse::set_allocated_gate_ip(::std::string* gate_ip) {
  if (gate_ip_ != &::google::protobuf::internal::kEmptyString) {
    delete gate_ip_;
  }
  if (gate_ip) {
    set_has_gate_ip();
    gate_ip_ = gate_ip;
  } else {
    clear_has_gate_ip();
    gate_ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gate_port = 2;
inline bool LoginResponse::has_gate_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginResponse::set_has_gate_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginResponse::clear_has_gate_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginResponse::clear_gate_port() {
  gate_port_ = 0u;
  clear_has_gate_port();
}
inline ::google::protobuf::uint32 LoginResponse::gate_port() const {
  return gate_port_;
}
inline void LoginResponse::set_gate_port(::google::protobuf::uint32 value) {
  set_has_gate_port();
  gate_port_ = value;
}

// optional uint32 user_account = 3;
inline bool LoginResponse::has_user_account() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginResponse::set_has_user_account() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginResponse::clear_has_user_account() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginResponse::clear_user_account() {
  user_account_ = 0u;
  clear_has_user_account();
}
inline ::google::protobuf::uint32 LoginResponse::user_account() const {
  return user_account_;
}
inline void LoginResponse::set_user_account(::google::protobuf::uint32 value) {
  set_has_user_account();
  user_account_ = value;
}

// optional .clientmsg.enumLoginResult result = 4;
inline bool LoginResponse::has_result() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginResponse::set_has_result() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginResponse::clear_has_result() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginResponse::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::clientmsg::enumLoginResult LoginResponse::result() const {
  return static_cast< ::clientmsg::enumLoginResult >(result_);
}
inline void LoginResponse::set_result(::clientmsg::enumLoginResult value) {
  assert(::clientmsg::enumLoginResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// optional uint32 chartype = 5;
inline bool LoginResponse::has_chartype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginResponse::set_has_chartype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginResponse::clear_has_chartype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginResponse::clear_chartype() {
  chartype_ = 0u;
  clear_has_chartype();
}
inline ::google::protobuf::uint32 LoginResponse::chartype() const {
  return chartype_;
}
inline void LoginResponse::set_chartype(::google::protobuf::uint32 value) {
  set_has_chartype();
  chartype_ = value;
}

// -------------------------------------------------------------------

// LoginGame

// required uint32 user_account = 1;
inline bool LoginGame::has_user_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGame::set_has_user_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGame::clear_has_user_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGame::clear_user_account() {
  user_account_ = 0u;
  clear_has_user_account();
}
inline ::google::protobuf::uint32 LoginGame::user_account() const {
  return user_account_;
}
inline void LoginGame::set_user_account(::google::protobuf::uint32 value) {
  set_has_user_account();
  user_account_ = value;
}

// -------------------------------------------------------------------

// ClientInit

// optional .CharInfo charinfo = 1;
inline bool ClientInit::has_charinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientInit::set_has_charinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientInit::clear_has_charinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientInit::clear_charinfo() {
  if (charinfo_ != NULL) charinfo_->::CharInfo::Clear();
  clear_has_charinfo();
}
inline const ::CharInfo& ClientInit::charinfo() const {
  return charinfo_ != NULL ? *charinfo_ : *default_instance_->charinfo_;
}
inline ::CharInfo* ClientInit::mutable_charinfo() {
  set_has_charinfo();
  if (charinfo_ == NULL) charinfo_ = new ::CharInfo;
  return charinfo_;
}
inline ::CharInfo* ClientInit::release_charinfo() {
  clear_has_charinfo();
  ::CharInfo* temp = charinfo_;
  charinfo_ = NULL;
  return temp;
}
inline void ClientInit::set_allocated_charinfo(::CharInfo* charinfo) {
  delete charinfo_;
  charinfo_ = charinfo;
  if (charinfo) {
    set_has_charinfo();
  } else {
    clear_has_charinfo();
  }
}

// optional .enumGetCharResult result = 2;
inline bool ClientInit::has_result() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientInit::set_has_result() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientInit::clear_has_result() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientInit::clear_result() {
  result_ = 0;
  clear_has_result();
}
inline ::enumGetCharResult ClientInit::result() const {
  return static_cast< ::enumGetCharResult >(result_);
}
inline void ClientInit::set_result(::enumGetCharResult value) {
  assert(::enumGetCharResult_IsValid(value));
  set_has_result();
  result_ = value;
}

// -------------------------------------------------------------------

// CreateChar

// optional .CharInfo charinfo = 1;
inline bool CreateChar::has_charinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreateChar::set_has_charinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreateChar::clear_has_charinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreateChar::clear_charinfo() {
  if (charinfo_ != NULL) charinfo_->::CharInfo::Clear();
  clear_has_charinfo();
}
inline const ::CharInfo& CreateChar::charinfo() const {
  return charinfo_ != NULL ? *charinfo_ : *default_instance_->charinfo_;
}
inline ::CharInfo* CreateChar::mutable_charinfo() {
  set_has_charinfo();
  if (charinfo_ == NULL) charinfo_ = new ::CharInfo;
  return charinfo_;
}
inline ::CharInfo* CreateChar::release_charinfo() {
  clear_has_charinfo();
  ::CharInfo* temp = charinfo_;
  charinfo_ = NULL;
  return temp;
}
inline void CreateChar::set_allocated_charinfo(::CharInfo* charinfo) {
  delete charinfo_;
  charinfo_ = charinfo;
  if (charinfo) {
    set_has_charinfo();
  } else {
    clear_has_charinfo();
  }
}

// optional uint32 mapid = 2;
inline bool CreateChar::has_mapid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreateChar::set_has_mapid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreateChar::clear_has_mapid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreateChar::clear_mapid() {
  mapid_ = 0u;
  clear_has_mapid();
}
inline ::google::protobuf::uint32 CreateChar::mapid() const {
  return mapid_;
}
inline void CreateChar::set_mapid(::google::protobuf::uint32 value) {
  set_has_mapid();
  mapid_ = value;
}

// optional uint32 cityid = 3;
inline bool CreateChar::has_cityid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CreateChar::set_has_cityid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CreateChar::clear_has_cityid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CreateChar::clear_cityid() {
  cityid_ = 0u;
  clear_has_cityid();
}
inline ::google::protobuf::uint32 CreateChar::cityid() const {
  return cityid_;
}
inline void CreateChar::set_cityid(::google::protobuf::uint32 value) {
  set_has_cityid();
  cityid_ = value;
}

// -------------------------------------------------------------------

// ClientExit

// optional uint32 charid = 1;
inline bool ClientExit::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientExit::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientExit::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientExit::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ClientExit::charid() const {
  return charid_;
}
inline void ClientExit::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// optional uint64 user_account = 2;
inline bool ClientExit::has_user_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientExit::set_has_user_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientExit::clear_has_user_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientExit::clear_user_account() {
  user_account_ = GOOGLE_ULONGLONG(0);
  clear_has_user_account();
}
inline ::google::protobuf::uint64 ClientExit::user_account() const {
  return user_account_;
}
inline void ClientExit::set_user_account(::google::protobuf::uint64 value) {
  set_has_user_account();
  user_account_ = value;
}

// -------------------------------------------------------------------

// SendChat

// optional .clientmsg.enumChatType type = 1;
inline bool SendChat::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendChat::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendChat::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendChat::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::clientmsg::enumChatType SendChat::type() const {
  return static_cast< ::clientmsg::enumChatType >(type_);
}
inline void SendChat::set_type(::clientmsg::enumChatType value) {
  assert(::clientmsg::enumChatType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 charid = 2;
inline bool SendChat::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendChat::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendChat::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendChat::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 SendChat::charid() const {
  return charid_;
}
inline void SendChat::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// optional string msg = 3;
inline bool SendChat::has_msg() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendChat::set_has_msg() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendChat::clear_has_msg() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendChat::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& SendChat::msg() const {
  return *msg_;
}
inline void SendChat::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SendChat::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void SendChat::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SendChat::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* SendChat::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SendChat::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SendGreet

// optional uint32 charid = 1;
inline bool SendGreet::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendGreet::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendGreet::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendGreet::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 SendGreet::charid() const {
  return charid_;
}
inline void SendGreet::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// optional uint32 greetid = 2;
inline bool SendGreet::has_greetid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendGreet::set_has_greetid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendGreet::clear_has_greetid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendGreet::clear_greetid() {
  greetid_ = 0u;
  clear_has_greetid();
}
inline ::google::protobuf::uint32 SendGreet::greetid() const {
  return greetid_;
}
inline void SendGreet::set_greetid(::google::protobuf::uint32 value) {
  set_has_greetid();
  greetid_ = value;
}

// -------------------------------------------------------------------

// WordWindow

// optional .enumWordmsgType type = 1;
inline bool WordWindow::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WordWindow::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WordWindow::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WordWindow::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::enumWordmsgType WordWindow::type() const {
  return static_cast< ::enumWordmsgType >(type_);
}
inline void WordWindow::set_type(::enumWordmsgType value) {
  assert(::enumWordmsgType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string content = 2;
inline bool WordWindow::has_content() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WordWindow::set_has_content() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WordWindow::clear_has_content() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WordWindow::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& WordWindow::content() const {
  return *content_;
}
inline void WordWindow::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void WordWindow::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void WordWindow::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WordWindow::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* WordWindow::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WordWindow::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ChangeCloth

// optional uint32 clothid = 1;
inline bool ChangeCloth::has_clothid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ChangeCloth::set_has_clothid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ChangeCloth::clear_has_clothid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ChangeCloth::clear_clothid() {
  clothid_ = 0u;
  clear_has_clothid();
}
inline ::google::protobuf::uint32 ChangeCloth::clothid() const {
  return clothid_;
}
inline void ChangeCloth::set_clothid(::google::protobuf::uint32 value) {
  set_has_clothid();
  clothid_ = value;
}

// optional uint32 charid = 2;
inline bool ChangeCloth::has_charid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ChangeCloth::set_has_charid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ChangeCloth::clear_has_charid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ChangeCloth::clear_charid() {
  charid_ = 0u;
  clear_has_charid();
}
inline ::google::protobuf::uint32 ChangeCloth::charid() const {
  return charid_;
}
inline void ChangeCloth::set_charid(::google::protobuf::uint32 value) {
  set_has_charid();
  charid_ = value;
}

// -------------------------------------------------------------------

// Assess

// optional .enumAssessType assesstype = 1;
inline bool Assess::has_assesstype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Assess::set_has_assesstype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Assess::clear_has_assesstype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Assess::clear_assesstype() {
  assesstype_ = 1;
  clear_has_assesstype();
}
inline ::enumAssessType Assess::assesstype() const {
  return static_cast< ::enumAssessType >(assesstype_);
}
inline void Assess::set_assesstype(::enumAssessType value) {
  assert(::enumAssessType_IsValid(value));
  set_has_assesstype();
  assesstype_ = value;
}

// optional .enumCharType chartype = 2;
inline bool Assess::has_chartype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Assess::set_has_chartype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Assess::clear_has_chartype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Assess::clear_chartype() {
  chartype_ = 1;
  clear_has_chartype();
}
inline ::enumCharType Assess::chartype() const {
  return static_cast< ::enumCharType >(chartype_);
}
inline void Assess::set_chartype(::enumCharType value) {
  assert(::enumCharType_IsValid(value));
  set_has_chartype();
  chartype_ = value;
}

// optional uint32 id = 3;
inline bool Assess::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Assess::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Assess::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Assess::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Assess::id() const {
  return id_;
}
inline void Assess::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 rank = 4;
inline bool Assess::has_rank() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Assess::set_has_rank() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Assess::clear_has_rank() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Assess::clear_rank() {
  rank_ = 0u;
  clear_has_rank();
}
inline ::google::protobuf::uint32 Assess::rank() const {
  return rank_;
}
inline void Assess::set_rank(::google::protobuf::uint32 value) {
  set_has_rank();
  rank_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace clientmsg

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clientmsg::enumLoginResult>() {
  return ::clientmsg::enumLoginResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::clientmsg::enumChatType>() {
  return ::clientmsg::enumChatType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_login_2eproto__INCLUDED
